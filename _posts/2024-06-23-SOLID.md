---
title: SOLID 원칙에 대한 간단 정리
date: 2024-06-23 13:00:00 +09:00
categories: [설계 & 아키텍처]
tags: [클린 아키텍쳐,객체 지향 프로그래밍]
---

클린 아키텍처(Clean Architecture) 책을 읽다가 나온 SOLID 원칙에 대한 이해를 높이기 위해 간단히 정리해봤어요.
책의 내용을 적절히 섞어가며 정리한 거라 참고용으로 보시면 좋을 것 같아요.

## SOLID 원칙이란?
- SOLID는 객체 지향 프로그래밍 설계의 다섯 가지 원칙을 나타내는 약어에요.
- 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해줘요.

## SOLID 원칙의 목표
- 변경에 유연해요.
- 이해하기 쉬워요.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 돼요.

## SOLID 원칙의 다섯 가지 원칙

### 1. SRP: 단일 책임 원칙 (Single Responsibility Principle)
- 모듈(클래스, 함수, 서비스 등)은 하나의 책임만 가져야 해요. 여기서 책임은 시스템의 특정 기능이나 요구 사항을 의미해요.
- 모듈은 하나의 **액터**(해당 변경을 요청하는 한 명 이상의 사람들)와 관련된 책임만을 가져야 하며, 여러 액터의 요구 사항을 동시에 다루지 않아야 해요.
- 응집성(cohesion)을 높이고 결합도(coupling)를 낮추는 데 도움이 돼요.

### 2. OCP: 개방-폐쇄 원칙 (Open-Closed Principle)
- 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 해요.
- 새로운 기능을 추가할 때 기존 코드를 변경하지 않고 확장할 수 있도록 설계해야 해요. (소프트웨어 아키텍처를 공부하는 가장 근본적인 이유)
- 인터페이스를 사용하여 의존성 역전을 일으키는 방법을 사용할 수 있어요.
- 캡슐화(정보은닉)를 사용하여 변경에 대한 영향을 최소화할 수 있어요.

### 3. LSP: 리스코프 치환 원칙 (Liskov Substitution Principle)
- P 프로그램에서 S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있을 때, o2 자리를 o1 으로 치환해도 P 프로그램의 행위가 변하지 않는다면 S는 T의 하위 이에요.
- 상속 관계에서 하위 클래스는 상위 클래스의 기능을 변경하지 않고 확장할 수 있어야 해요.

### 4. ISP: 인터페이스 분리 원칙 (Interface Segregation Principle)
- 클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 해요.
- 소스 코드 의존성의 경우, 불필요한 재컴파일과 재배포를 강제하게 돼요.
- 아키텍처 수준에서도 불필요한 의존성이 발생하면 불필요한 재배를 발생시킬 수 있어요.

### 5. DIP: 의존성 역전 원칙 (Dependency Inversion Principle)
- 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 말아야해요.
- 자바와 같은 정적 타입 언어에서는 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야한다는 뜻이에요.
- 아래는 책에서 나온 구체적인 코딩 실천법이에요.
  - 변동성이 큰 구체 클래스를 참조하지 말라.
  - 변동성이 큰 구체 클래스로부터 파생하지 말라.
  - 구체 함수를 오버라이드 하지 말라.
  - 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.
- 바람직하지 못한 의존성을 처리할 때 **추상 팩토리**를 사용할 수 있어요.
